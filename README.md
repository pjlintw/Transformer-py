# Transformer-py: a Flexible Framework for POS tagging.

[**Data**](#dataset-and-preprocessing) | [**Training**](#run-bert-variants-for-pos-tagging)

The repository works on fine-tuning of the pre-trained Transformer-based models for Parts-of-speech (POS) tagging. We leverage `chtb_0223.gold_conll`, `phoenix_0001.gold_conll`, `pri_0016.gold_conll` and `wsj_1681.gold_conll` annotated file as dataset for fine-tuning. To reproduce the results, follow the steps below.

In the literature, the initial layers are used to encode general, semantic-irrelevant information. The middle layers usually enable them to produce information-rich representations. The latter layers are good at encoding the abstractive and task-oriented semantic representation. We develop a flexible framework to run such experiments. 

* New February 22th, 2021: Data preprocessing and data information.
* New March 8th, 2021: Train the BERT and custom model, dataset loading script.
    
## TO-DO
* Experiments of Linear Probing.
* Experiments of data efficiency.


## Installation

### Python version

* Python >= 3.8

### Environment

Create an environment from file and activate the environment.

```
conda env create -f environment.yaml
conda activate fabian-pinjie
```

If conda fails to create an environment from `environment.yaml`. This may be caused by the platform-specific build constraints in the file. Try to create one by installing the important packages manually. The `environment.yaml` was built in macOS.

**Note**: Running `conda env export > environment.yaml` will include all the 
dependencies conda automatically installed for you. Some dependencies may not work in different platforms.
We suggest you to use the `--from-history` flag to export the packages to the environment setting file.
Make sure `conda` only exports the packages that you've explicitly asked for.

```
conda env export > environment.yaml --from-history
```

## Dataset and Preprocessing

### Dataset concatenation

We use `chtb_0223.gold_conll`, `phoenix_0001.gold_conll`, `pri_0016.gold_conll` and `wsj_1681.gold_conll` as the data for fine-tuning the pre-trained model.
These files are in the `data` folder. We combine them as one file `sample.conll` for preprocessing in the next step.

```
cd data
cat *.gold_conll >> sample.conll
```

In the following steps, you will preprocess the collected file `sample.conll`, then split them into `sample.train`, `sample.dev` and `sample.test`
for building the datasets. You have to change the relative path to `--datasets_name` if you're using a different file directory .


### Preprocessing and Dataset Splitting

The file `sample.conll` contains irrelevant information for training the neural nets.
We only need the sequence of observation, POS tags and the word position for the positional embedding in the transformer. Running `data_preprocess.py` to extract `word position`, `word` and `POS tag` and write it to
`sample.tsv` in which `word position`, `word` and `POS tag` are separated by tab. 

The arguments `--dataset_name` and `output_dir` are the file to be passed to the program and the repository for the output file respectively. 

It generates `sample.tsv` for all examples and `sample.train`, `sample.dev` and `sample.test` for the network training.  The examples will be shuffled in the scripts and split into `train`, `validation` and `test` files.  The arguments `--eval_samples` and `--test_samples`
decide the number of samples will be selected from examples. In OntoNotes datasets, we select 67880 for training set, 2000 for validation and test sets respectively. To preprocess and split the datasets, you need to run the code below. 

```python
python data_preprocess.py \
  --dataset_name sample.conll \
  --output_dir ./ \
  --eval_samples 2000 \
  --test_samples 2000 
```

Or just run the bash script `source ./run_preprocess.sh` in the command line. The output file `sample.tsv` will under the 
path `--output_dir`. You will get the result.

```
Loading 69880 examples
Seed 49 is used to shuffle examples
Saving 69880 examples to sample.tsv
Saving 65880 examples to sample.train
Saving 2000 examples to sample.dev
Saving 2000 examples to sample.test
```

Make sure that **the datasets** you passed to the argument `--dataset_name` has larger number examples for splitting out develop and test set. The example files may have no example, if the splitting number for eval and test sets is greater than the example in `sample.conll`.


### Data Information

To get the information regarding the observations and POS taggings. Execute the script `data_information.py` to compute 
the percentiles, maximum, minimum and mean of the sequence length, number of examples, POS tags and its percentage.

The arguments `--dataset_name` and `output_dir` are the file to be passed to the program and the repository for the output file respectively. 

```python
python data_information.py \
  --dataset_name sample.tsv \
  --output_dir ./
```

or run `source ./run_information.sh` in the command line. The output file `sample.info` will be exported in the  `--output_dir` directory.

### Train with Custom OntoNotes v4.0

We use our dataset loading script `ontonotes_v4.py`for creating dataset. The script builds the train, validation and test sets from those 
dataset splits obtained by the `data_preprocess.py` program. 
Make sure the dataset split files `sample.train`, `sample.dev` , and `sample.test` are included in the datasets folder `data/` your dataset folder.

If you get an error message like:

```
pyarrow.lib.ArrowTypeError: Could not convert 1 with type int: was not a sequence or recognized null for conversion to list type
```

You may have run other datasets in the same folder before. The Huggingface already created `.arrow` files once you run a loading script. These files are for reloading the datasets quickly.

Try to move the dataset you would like to use to the other folder and modify the path in the loading scipt. 

Or delete the relavent folder and files in the `.cache` for datasets. `cd ~/USERS_NAME/.cache/huggingface/datasets/` and `rm -r *`. This means that all the loading records will be removed and
 Hugginface will create the `.arrows` files again, including the previous laoding records. 


## Save the Results

We suggest that using `Weights & Biass` to save the configuration, loss and evaluation metrics for you.
To connect your own `Weights & Biass` account. Just installing the packages using `pip install wandb`
and login it. The `trainer` in `run_pos.py` will automatically log the `TrainingArguments`, losses and evaluation
metrics and model information to your account. 

```
wandb login
```

You can specify which project folder for saving files. For example, set project name 
to the environment variable.

```
export WANDB_PROJECT=TEST_PROJECT
export WANDB_WATCH=all
```

## Run BERT variants for POS tagging

We evaluate the BERT on linear probing test to see which layer capture more linguistic structure 
information in their contextual representations. The output layers for classifying the POS tags are added on the different layers of BERT. We only train these layer's weights.

We treat BERT as a feature extractor to provide fixed pre-trained contextual embeddings.
In the script, we set `requires_grad` false for BERT model. If you would like to fine-tune the whole model, just comment those lines.

In certain cases, rather than fine-tuning the entire pre-trained model end-to-end, it can be beneficial to obtain pre-trained contextual embeddings, which are fixed contextual representations of each input token generated from the hidden layers of the pre-trained model. This should also mitigate most of the out-of-memory issues.

We found that executing a  64 minibatch size trained with maximal sequence length is pretty slow. 
The maximal sequence length, in OntoNotes is 228, is usually an extreme case. We gain huge improvement on the runtime for a minibatch by using 63 to `max_seq_length` covering 99% of sequence length.


### Train the official BERT model

The official Huggingface BERT for sequence labeling task using `BertForTokenClassification` class. 
The model leverages a pre-trained BERT, dropout and a classifier layer.
To run these settings, you can run

```python
python run_pos.py \
 --model_name_or_path bert-base-cased \
 --output_dir /tmp/pos-exp-1 \
 --task_name pos \
 --dataset_script ontonotes_v4.py \
 --max_seq_length 63 \
 --per_device_train_batch_size 48 \
 --per_device_eval_batch_size 48 \
 --num_train_epochs 3 \
 --do_train \
 --do_eval \
 --do_predict
 --learning_rate 1e-2 
![](data:image/jpeg;base64,ewogImNlbGxzIjogWwogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIjxoMT48Y2VudGVyPlBocmFzZS1iYXNlZCBNYWNoaW5lIFRyYW5zbGF0aW9uPC9jZW50ZXI+PC9oMT5cbiIsCiAgICAiPGg0PjxjZW50ZXI+UGluLUppZSBMaW48L2NlbnRlcj48L2g0PlxuIiwKICAgICI8Y2VudGVyPnBpbGkwMDAwMUBzdHVkLnVuaS1zYWFybGFuZC5kZTwvY2VudGVyPiIKICAgXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbCiAgICAiIyMgMSBJbnRyb2R1Y3Rpb24iCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIlRoZSBJQk0gTW9kZWwgMSBhc3N1bWVzIHRoYXQgZWFjaCB3b3JkIGluIHRoZSB0YXJnZXQgc2VudGVuY2UgaXMgYSB0cmFuc2xhdGlvbiBvZiBleGFjdGx5IHplcm8gb3Igb25lIHdvcmQgb2YgdGhlIHNvdXJjZSBzZW50ZW5jZS4gSG93ZXZlciwgdGhlIHRyYW5zbGF0aW9uIHF1YWxpdHkgb2J0YWluZWQgZnJvbSB3b3JkLWJ5LXdvcmQgdHJhbnNsYXRpb24gaXNuJ3QgZmx1ZW50IGFuZCByZWFkYWJsZS4gQWRkaXRpb25hbGx5LCB0aGUgcmVzdWx0IGRvZXMgbm90IGFsd2F5cyBjb3ZlciB0aGUgbmVjZXNzYXJ5IG1lYW5pbmcgZnJvbSBzb3VyY2Ugc2VudGVuY2UuIEluIHRoaXMgd29yaywgd2UgdGFja2xlIHRoZXNlIHByb2JsZW1zIGJ5IGxldmVyYWdpbmcgcGhyYXNlLWJhc2VkIHRyYW5zbGF0aW9uIG1vZGVscy4gVGhlIG1vZGVscyBlc3RpbWF0ZSB0aGUgY29uZGl0aW9uYWwgcHJvYmFiaWxpdHkgYnVpbHQgb24gdGhlIGV4dHJhY3RlZCBwaHJhc2VzIGZyb20gd29yZCBhbGlnbm1lbnQuIFdlIGRlbW9uc3RyYXRlIHRoYXQgdGhlIHJlc3VsdHMgZnJvbSBwaHJhc2UtYmFzZWQgbW9kZWwgZ2FpbiB0aGUgaW1wcm92ZW1lbnRzIGluIHRlcm1zIG9mIHRoZSBmbHVlbmN5IGFuZCB0aGUgYWRlcXVhY3kgdGhhbiB3b3JkLWJhc2VkIHRyYW5zbGF0aW9uLiIKICAgXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbCiAgICAiT3VyIGdvYWwgaXMgdG8gZXN0aW1hdGUgdGhlIGNvbmRpdGlvbmFsIHByb2JhYmlsaXR5IGZvciBhIHBocmFzZS1ieS1waHJhc2UgdHJhbnNsYXRpb24gbW9kZWwuIEl0IHRyYW5zbGF0ZXMgYW4gRW5nbGlzaCBzZW50ZW5jZSBhbmQgYSBGcmVuY2ggc2VudGVuY2UuIFdlIGRlbm90ZSBwKGV8ZikgZm9yIHRoZSBjb25kaXRpb25hbCBwcm9iYWJpbGlzdGljIG1vZGVsLiBJbiB0aGUgd29ya3MsIHRoZSBzb3VyY2Ugc2VudGVuY2UgcmVmZXJzIHRvIHRoZSBGcmVuY2ggc2VudGVuY2UgdGhhdCB3ZSB3b3VsZCBsaWtlIHRvIHRyYW5zbGF0ZS4gV2UgYWxzbyB1c2UgZm9yZWlnbiBsYW5ndWFnZSBvciBmb3JlaWduIHNlbnRlbmNlcyBmb3IgaXQuIFRoZSB0YXJnZXQgbGFuZ3VhZ2UgaXMgdGhlIEVuZ2xpc2ggc2VudGVuY2UsIHJlc3VsdHMgb2YgdHJhbnNsYXRpb24gb2J0YWluZWQgZnJvbSBvdXIgbW9kZWwuXG4iLAogICAgIlxuIiwKICAgICJJbiB0aGUgcHJvZ3JhbW1pbmcgcGFydHMsIHdlIGFsd2F5cyB1c2UgYHNvdXJjZWAgYW5kIGBzcmNgIGZvciB0aGUgd29yZCwgIHBocmFzZSBvciBzZW50ZW5jZSBpbiBGcmVuY2guIE9uIHRoZSBvdGhlciBoYW5kLCBgdGFyZ2V0YCBhbmQgYHRndGAgYXJlIHRoZSB2YXJpYWJsZSBuYW1lcyBmb3Igd29yZHMsIHBocmFzZXMgYW5kIHNlbnRlbmNlcyBpbiBFbmdsaXNoLlxuIiwKICAgICJcbiIsCiAgICAiVGhpcyBwcm9qZWN0IG1ha2VzIHRoZSBjb250cmlidXRpb25zIGFzIGZvbGxvdzpcbiIsCiAgICAiLSBJbXByb3ZlIHRoZSB0cmFuc2xhdGlvbiBtb2RlbCB1c2luZyAqKnBocmFzZSBleHRyYWN0aW9uKiouXG4iLAogICAgIi0gRWZmaWNpZW50IHNlYXJjaCBwb3NzaWJsZSB0cmFuc2xhdGVkIHBocmFzZSBmb3Igc3VyY2UgcGhyYXNlIGR1cmluZyB0aGUgcGhyYXNlIHRyYW5zbGF0aW9uIHByb2Nlc3MuICBcbiIKICAgXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbCiAgICAiIyMgMiBQaHJhc2UtYmFzZWQgTW9kZWxzIgogICBdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFsKICAgICJJbiB0aGlzIHNlY29uZCwgd2Ugbm93IGludHJvZHVjZSB0aGUgcGhyYXNlLWJhc2VkIG1vZGVscyBvbiBub2lzeS1jaGFubmVsIGFzc3VtcHRpb24sIHRoZW4gcHJvdmlkZSBtb3JlIGRldGFpbHMgb24gaG93IHdlIGVzdGltYXRlIHRoZSBwcm9iYWJpbGlzdGljIG1vZGVsIGFuZCB0cmFuc2xhdGUgYSBzZW50ZW5jZSB1c2luZyBkZW5jb2RpbmcgYWxnb3JpdGhtLiIKICAgXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbCiAgICAiKipTdGF0aXN0aWNhbCBNYWNoaW5lIFRyYW5zbGF0aW9uLioqIFdlIGRlZmluZSBQKGV8ZikgYXMgYSBjb25kaXRpb25hbCBwcm9iYWJpbGlzdGljIG1vZGVsIG9mIGEgRnJlbmNoIHNlbnRlbmNlICoqZioqIFxuIiwKICAgICJnaXZlbiBhbiBFbmdsaXNoIHNlbnRlbmNlICoqZSoqLiBNYXRoZW1hdGljYWxseSwgd2UgY2FuIGFwcGx5IEJheWVzIHJ1bGUgdG8gZGVyaXZlIHRoZSBmb3JtdWxhLCB3aGljaCBpcyBrbm93biBhcyAqKm5vaXN5LWNoYW5uZWwgbW9kZWwqKjogXG4iCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIlxcYmVnaW57YWxpZ259XG4iLAogICAgIlAoZXxmKSBcXHByb3B0byBQKGZ8ZSlQKGUpXFxcXFxuIiwKICAgICJcXGVuZHthbGlnbn0iCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIndoZXJlIHRoZSBjb25kaXRpb25hbCBwcm9iYWJpbGlzdGljIG1vZGVsICoqUChlfGYpKiogaXMgcHJvcG9ydGlvbmFsIHRvIGEgdHJhbnNsYXRpb24gbW9kZWwgKipQKGZ8ZSkqKiBhbmQgYSBsYW5ndWFnZSBtb2RlbCAqKlAoZSkqKi4gSW4gdGhlIHdvcmQtYmFzZWQgbW9kZWwsIHRoaXMgdHJhbnNsYXRpb24gbW9kZWwgKipQKGZ8ZSkqKiBjYW4gYmUgc2VlbiBhcyB0aGUgc3VtbWF0aW9uIG9mIGFsbCBwcm9iYWJpbGl0aWVzIGZvciB0aGUgYWxpZ25tZW5zIGJldHdlZW4gRnJlbmNoIGFuZCBFbmdsaXNoIHNlbnRlbmNlcy4gSW4gcHJhY3RpY2UsIGl0IGlzIGluZmVhc2libGUgdG8gY29tcHV0ZSBhbGwgcG9zc2libGUgYWxpZ25tZW50cy4gVGhlIHdvcmQtYmFzZWQgdHJhbnNsYXRpb24gbW9kZWxzIGFwcHJveGltYXRlICoqUChmfGUpKiogd2l0aCBhbiBhc3N1bXBpdGlvbiB0aGF0IGVhY2ggd29yZCBpbiB0aGUgRnJlbmNoIHNlbnRlbmNlIGlzIGEgdHJhbnNsYXRpb24gb2YgZXhhY3RseSB6ZXJvIG9yIG9uZSB3b3JkIG9mIHRoZSBFbmdsaXNoIHNlbnRlbmNlLiIKICAgXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbCiAgICAiXFxiZWdpbnthbGlnbn1cbiIsCiAgICAiUChmfGUpICYgPSBcXHN1bV97YX0gUChmLGF8ZSkgXFxcXFxuIiwKICAgICImIFxccHJvcHRvIFxccHJvZF97aj0xfV57bF97Zn19IFxcc3VtX3tpPTF9XntsX3tlfX0gUChmX3tqfXxlX3tpfSkgXFxcXFxuIiwKICAgICJcXGVuZHthbGlnbn0iCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIkhvd2V2ZXIsIHN1Y2ggd29yZC1iYXNlZCBtb2RlbCB1c2VzIG9ubHkgbGV4aWNhbCB0cmFuc2xhdGlvbiBwcm9iYWJpbGl0aWVzIGFuZCBub3Qgc3VmZmljaWVudCB0byB0cmFuc2xhdGUgYSBzZW50ZW5jZS4gT24gdGhlIG90aGVyIGhhbmQsIHRoZSBwaHJhc2VkLWJhc2VkIG1vZGVsIHJld3JpdGVzIHRoZSB0cmFuc2xhdGlvbiBtb2RlbCAqKnAoZnxlKSoqIGFzIHRoZSBwcm9kdWN0IG9mIHBocmFzZSB0cmFuc2xhdGlvbiBwcm9iYWJpbGl0eSAkXFxwaGkoZl97aX18ZV97aX0pJCBhbmQgZGlzdGFuY2UtYmFzZWQgcmVvcmRlcmluZyBtb2RlbCAkZChzdGFydF97aX0tZW5kX3tpLTF9LTEpJC4iCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIlxcYmVnaW57YWxpZ259XG4iLAogICAgIlBfe3BocmFzZX0oZnxlKSA9IFxccHJvZF97aT0xfV57SX0gXFxwaGlfKGZfe2l9fGVfe2l9KSBkKHN0YXJ0X3tpfS1lbmRfe2ktMX0tMSlcbiIsCiAgICAiXFxlbmR7YWxpZ259IgogICBdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFsKICAgICIqKkxvZy1wcm9iYWJpbGl0eSBGb3JtKiogSW4gdGhlIGltcGxlbWVudGF0aW9uLCB0aGUgcHJvZ3JhbSBmaW5kcyB0aGUgbW9zdCBwcm9iYWJsZSBFbmdsaXNoIHRyYW5zbGF0aW9uIHN1Y2ggdGhhdCBpdCBtYXhpbWl6ZSB0aGUgZm9ybXVsYS4gVG8gYXZvaWQgb3ZlcmZsb3csIHdlIHJlcGxhY2UgdGhlIHByb2RjdCB3aXRoIGxvZy1wcm9iYWJpbGl0eTogIgogICBdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFsKICAgICJcXGJlZ2lue2FsaWdufVxuIiwKICAgICJlKiAmID0gYXJnbWF4X3tlfSBQKGV8ZikgXFxcXFxuIiwKICAgICImID0gYXJnIG1heF97ZX0gUF97cGhyYXNlfShmfGUpIFxcdGltZXMgUF97TE19KGUpIFxcXFxcbiIsCiAgICAiJiA9IGFyZyBtYXhfe2V9IGxvZyBQX3twaHJhc2V9KGZ8ZSkgKyBsb2cgUF97TE19KGUpIFxcXFxcbiIsCiAgICAiXFxlbmR7YWxpZ259XG4iCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIioqUGhyYXNlIEV4dHJhY3Rpb24uKiogVGhlIHBocmFzZS1iYXNlZCBtb2RlbCBidWlsZHMgYSBwaHJhc2UgdGFibGUgb24gdGhlIHdvcmQgYWxpZ25tZW50cy4gV2UgZ2V0IHRoZSB3b3JkIGFsaWdtZW50IGZyb20gb3VyIElCTSBNb2RlbCBpbXBsZW1ldGF0aW9uIHJ1bm5pbmcgb24gMTAwayBgSGFuc2FyZHNgIEZyZW5jaC1FbmdsaXNoIGRhdGFzZXN0cy4gXG4iLAogICAgIlxuIiwKICAgICJcbiIsCiAgICAiVGhlcmUgYXJlIHR3byBzdGVwcyB0byBleHRyYWN0IHRoZSBwb3NzaWJsZSBwaHJhc2VzIGZyb20gd29yZCBhbGlnbm1lbnQuIEZpcnN0LCBsb29wIGFsbCBwb3NzaWJsZSBwaHJhc2VzIGluIEdlcm1hbiBtYXRjaGluZyB0aGUgbWluaW1hbCBwaHJhc2UgaW4gRW5nbGlzaC4gU2Vjb25kLCBmaW5kIHRoZSBzaG9ydGVzdCBwaHJhc2UgaW4gRW5nbGlzaCB0aGF0IGluY2x1ZGVzIGFsbCB0aGUgZW50ZXJwYXJ0cyBmb3IgdGhlIEdlcm1hbiB3b3Jkcy4gIgogICBdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFtdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFsKICAgICIqKkRlY29kaW5nKiogVG8gb2J0YWluIHRoZSBiZXN0IHRyYW5zbGF0ZWQgc2VudGVuY2UgZnJvbSBhIGZvcmVpZ24gaW5wdXQgc2VudGVuY2UsIG91ciBwaHJhc2UtYmFzZWQgbW9kZWwgY29tcHV0ZXMgc2NvcmVzIGZvciBwYXJ0aWFsIHRyYW5zbGF0aW9ucyBpbiB0aGUgZGVjb2Rpbmcgc3RlcC4gSW4gdGhlIGRlY29kaW5nIHByb2dyYW0sIHRoZSBwYXJ0aWFsIHRyYW5zbGF0aW9ucyBhcmUgYSBzdGFja2VkIHBocmFzZSBjYWxsZWQgaHlwb3RoZXNpcy4gV2UgdXNlcyBhIGhldXJzdGljIGFsZ29yaXRobSBjYWxsZWQgKipiZWFtLXNlYXJjaCoqLiBUaGUgYmVhbS1zZWFyY2ggZGVjb2RpbmcgYWxnb3JpdGhtIGtlZXBzIGEgKiprKiogZml4ZWQgbnVtYmVyIG9mIGh5cG90aGVzaXNlIGF0IGVhY2ggdGltZSBzdGVwcy4gSXQgZ2VuZXJhdGVzIHRoZSB0cmFuc2xhdGlvbiBwaHJhc2UgYnkgcGhyYXNlIGZyb20gbGVmdC10by1yaWdodC4gXG4iCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIlxcYmVnaW57YWxpZ259XG4iLAogICAgImFyZ21heF97ZX0gbG9nIHBfe3RyYW5zbGF0aW9ufShnLCBhIHwgZSkgKyBsb2cgcF97TE19KGUpIFxcXFxcbiIsCiAgICAiXFxlbmR7YWxpZ259IgogICBdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFtdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFsKICAgICIqKkRhdGFzZXQuKiogSW4gb3JkZXIgdG8gZXZhbHV0ZSB0aGUgWmlwZidzIGxhdywgd2Ugc2VsZWN0IGZvdXIgY29ycHVzIHRvIHNlZSB3aGV0aGVyIGl0IGlzIHRydWUgZm9yIGRpZmZlcmVudCBkb21haW5zIG9mIHRleHQgYW5kIGxhbmd1YWdlcy4gRmlyc3QsICoqdGhlIEtpbmcgSmFtZXMgQmlibGUgKEtKQikqKiAgaXMgYW4gRW5nbGlzaCB0cmFuc2xhdGlvbiBvZiB0aGUgQ2hyaXN0aWFuIEJpYmxlIHdoaWNoIGNvbnNpc3RzIG9mIDMxMTAyIHNlbnRlbmNlcy4gU2Vjb25kLCAqKnRoZSBKdW5nbGUgQm9vayoqIGlzIGEgY29sbGVjdGlvbiBvZiBzdG9yaWVzIHdoaWNoIGhhcyByb3VnaGx5IDU0ODg3IHdvcmRzIGNvdW50aW5nIGZyb20gc2VnbWVudHMuIEZvciBsYXN0IHR3byBjb3Jwb3JhLCB3ZSB1c2UgcGFyYWxsZWwgbmV3cyB0ZXh0cywgKipTRVRpbWVzIFR1cmtpc2gtQnVsZ2FyaWFuIGNvcnB1cyoqLCB3aGljaCBiYXNlIG9uIHRoZSBTRVRpbWVzLmNvbSBuZXdzIHBvcnRhbCBhbmQgY29uc2lzdCAyMDYwNzEgcGFyYWxsZWwgc2VudGVuY2VzIGluIGJvdGggVHVya2lzaCBhbmQgQnVsZ2FyaWFuIGxhbmd1YWdlLiIKICAgXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbCiAgICAiV2UgdXNlcyAqKkhhbnNhcmRzKiogQ2FuYWRpYW4tRW5nbGlzaCBkYXRhc2V0cy4gVGhlIGRhdGFzZXRzIGRlcnZpZWQgZnJvbSBvdXIgd29yZCBhbGlnbm1lbnQgYXNzaWdubWVudC4gSXQgY29uc2lzdHMgb2YgMTAwayBwYXJhbGxlbCBzZW50ZW5jZXMgaW4gRnJlbmNoIGFuZCBFbmdsaXNoLiIKICAgXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbCiAgICAiIyMjIDEuMSBFeHBlcmllbWVudHNcbiIsCiAgICAiXG4iLAogICAgIkluIHRoaXMgc2VjdGlvbiwgd2UgYnJpZWZseSBpbnRyb2R1Y2Ugb3VyIGRhdGFzZXRzOiB0aGUgS2luZyBKYW1lcyBCaWJsZSwgdGhlIEp1bmdsZSBCb29rIGFuZCB0aGUgU0VUaW1lc1R1cmtpc2gtQnVsZ2FyaWFuIHBhcmFsbGVsIG5ld3NwYXBlciB0ZXh0LiBJbiBhZGRpdGlvbiwgd2UgZGVzY3JpcHQgb3VyIGltcGxlbWF0aW9uIGRldGFpbCBoZXJlLlxuIiwKICAgICJcbiIsCiAgICAiKipFeHBlcmltZW50YWwgc2V0dGluZ3MuKiogV2UgdXNlcyB0d28gc2NyaXB0cyBmb3IgYnVpbGRpbmcgdGhlIGRhdGEgYW5kIHBsb3RpbmcgdGhlIFppcGYncyBsYXcgY2hhcnRzIHNlcGFyYXRlbHkuIEZvciBlYWNoIGNvcnB1cywgd2UgY291bnQgaXRzIHdvcmQgZnJlcXVlbmN5IGFuZCBzdG9yZSB3b3JkLWZyZXF1ZW5jeSBwYWlyIGFzIGtheS12YWx1ZSBtYXBwaW5nIGluIGEgZGljdGlvbmFyeSBzb3J0aW5nIGJ5IGRlc2NlbmRpbmcgb3JkZXIuIFdlIHRva2VuaXplIHNlbnRlbmNlIGJ5IHdoaXRlc3BhY2UgYW5kIHJlbWFpbiBhbGwgc3RvcCB3b3JkcyBhbmQgcHVuY3R1YXRpb24gcmVtYXJrcy4gQmVjYXVzZSBpdCBkb2VzIG5vdCBlZmZlY3QgdGhlIHJlc3VsdCBvZiB6aXBmJ3MgbGF3LiBJbiBpbXBsZW1lbnRhdGlvbiwgd2UgY29sbGVjdCBhbGwgY29ycHVzIG9uIGEgZm9sZGVyIGFuZCBwcmVwcm9jZXNzIHRoZW0gd2l0aGluIGEgbG9vcC4gV2UgZHVtcCB0aGUgd29yZC1mcmVxdW5lY3kgcGFpcnMgdG8gYSBgLmpzb25gIGZpbGUgZm9yIGVhY2ggY29ycHVzLiIKICAgXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbCiAgICAiIyMgMyBFZXhwZXJpbWVudHMiCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIkluIHRoaXMgc2VjdGlvbiwgd2UgYnJpZWZseSBpbnRyb2R1Y2Ugb3VyIGRhdGFzZXRzOiB0aGUgS2luZyBKYW1lcyBCaWJsZSwgdGhlIEp1bmdsZSBCb29rIGFuZCB0aGUgU0VUaW1lc1R1cmtpc2gtQnVsZ2FyaWFuIHBhcmFsbGVsIG5ld3NwYXBlciB0ZXh0LiBJbiBhZGRpdGlvbiwgd2UgZGVzY3JpcHQgb3VyIGltcGxlbWF0aW9uIGRldGFpbCBoZXJlLlxuIiwKICAgICJcbiIsCiAgICAiKipFeHBlcmltZW50YWwgc2V0dGluZ3MuKiogV2UgdXNlcyB0d28gc2NyaXB0cyBmb3IgYnVpbGRpbmcgdGhlIGRhdGEgYW5kIHBsb3RpbmcgdGhlIFppcGYncyBsYXcgY2hhcnRzIHNlcGFyYXRlbHkuIEZvciBlYWNoIGNvcnB1cywgd2UgY291bnQgaXRzIHdvcmQgZnJlcXVlbmN5IGFuZCBzdG9yZSB3b3JkLWZyZXF1ZW5jeSBwYWlyIGFzIGtheS12YWx1ZSBtYXBwaW5nIGluIGEgZGljdGlvbmFyeSBzb3J0aW5nIGJ5IGRlc2NlbmRpbmcgb3JkZXIuIFdlIHRva2VuaXplIHNlbnRlbmNlIGJ5IHdoaXRlc3BhY2UgYW5kIHJlbWFpbiBhbGwgc3RvcCB3b3JkcyBhbmQgcHVuY3R1YXRpb24gcmVtYXJrcy4gQmVjYXVzZSBpdCBkb2VzIG5vdCBlZmZlY3QgdGhlIHJlc3VsdCBvZiB6aXBmJ3MgbGF3LiBJbiBpbXBsZW1lbnRhdGlvbiwgd2UgY29sbGVjdCBhbGwgY29ycHVzIG9uIGEgZm9sZGVyIGFuZCBwcmVwcm9jZXNzIHRoZW0gd2l0aGluIGEgbG9vcC4gV2UgZHVtcCB0aGUgd29yZC1mcmVxdW5lY3kgcGFpcnMgdG8gYSBgLmpzb25gIGZpbGUgZm9yIGVhY2ggY29ycHVzLiIKICAgXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbCiAgICAiKipEYXRhc2V0KioiCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIioqV29yZCBBbGlnbm1lbnQqKiBQaHJhc2UtYmFzZWQgdHJhbnNsYXRpb24gbW9kZWwgZXh0cmFjdHMgYWxsIHBvc3NpYmxlIHBocmFzZXMgZnJvbSB0aGUgd29yZC10by13b3JkIGFsaWdubWVudHMgYW5kIHRhaW5lZCBvbiB0aGVzZSBmaWxlLiBXZSBvYnRhaW5lZCB0aGUgd29yZCBhbGlnbWVudCBmaWxlcyBieSBydW5uaW5nIG91ciBJQk0gbW9kZWwgMS4gIgogICBdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFtdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFsKICAgICIqKlRyYW5zbGF0aW9uIEV4YW1wbGVzKioiCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogW10KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogW10KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIioqRXZhbHVhdGlvbiBNZXRyaWNzKioiCiAgIF0KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogW10KICB9LAogIHsKICAgImNlbGxfdHlwZSI6ICJtYXJrZG93biIsCiAgICJtZXRhZGF0YSI6IHt9LAogICAic291cmNlIjogWwogICAgIiMjIDQgQ29uY2x1c2lvbiIKICAgXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbXQogIH0sCiAgewogICAiY2VsbF90eXBlIjogIm1hcmtkb3duIiwKICAgIm1ldGFkYXRhIjoge30sCiAgICJzb3VyY2UiOiBbCiAgICAiMjAxNyAsIEJlYW0gc2VhcmNoIHN0cmF0ZWdpZXMgZm9yIG5ldXJhbCBtYWNoaW5lIHRyYW5zbGF0aW9uIgogICBdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFtdCiAgfSwKICB7CiAgICJjZWxsX3R5cGUiOiAibWFya2Rvd24iLAogICAibWV0YWRhdGEiOiB7fSwKICAgInNvdXJjZSI6IFtdCiAgfQogXSwKICJtZXRhZGF0YSI6IHsKICAia2VybmVsc3BlYyI6IHsKICAgImRpc3BsYXlfbmFtZSI6ICJQeXRob24gMyIsCiAgICJsYW5ndWFnZSI6ICJweXRob24iLAogICAibmFtZSI6ICJweXRob24zIgogIH0sCiAgImxhbmd1YWdlX2luZm8iOiB7CiAgICJjb2RlbWlycm9yX21vZGUiOiB7CiAgICAibmFtZSI6ICJpcHl0aG9uIiwKICAgICJ2ZXJzaW9uIjogMwogICB9LAogICAiZmlsZV9leHRlbnNpb24iOiAiLnB5IiwKICAgIm1pbWV0eXBlIjogInRleHQveC1weXRob24iLAogICAibmFtZSI6ICJweXRob24iLAogICAibmJjb252ZXJ0X2V4cG9ydGVyIjogInB5dGhvbiIsCiAgICJweWdtZW50c19sZXhlciI6ICJpcHl0aG9uMyIsCiAgICJ2ZXJzaW9uIjogIjMuNy4wIgogIH0KIH0sCiAibmJmb3JtYXQiOiA0LAogIm5iZm9ybWF0X21pbm9yIjogNAp9Cg==)```

### Train Linear Probing BERT  

Linear probing BERT is an architecture to extract the fixed contextual representations from the BERT.
It aims to evaluate which layer captures linguistic structure information in their features.

The custom model is `bert-base-cased`. Therefore, it has one embedding layer in 12 BERT layer in 
BERT model. If you use a classifier on top of 12th BERT's layer. It is same as the standard BERT that 
`BertForTokenClassification` class creats for you. 

To train BERT model on linear probing setting, you have to specify `linear-probing-bert.py` to
the option `--model_name_or_path` and pass integer indicating on which BERT's layer the classifier heads on.

```python
 python run_pos.py \
 --model_name_or_path models/linear-probing-bert.py \
 --output_dir /tmp/pos-exp-1 \
 --task_name pos \
 --dataset_script ontonotes_v4.py \
 --max_seq_length 63 \
 --per_device_train_batch_size 48 \
 --per_device_eval_batch_size 48 \
 --max_steps 120 \
 --do_train \
 --do_eval \
 --do_predict \
 --max_train_samples 10000 \
 --max_val_samples 300 \
 --max_test_samples 300 \
 --logging_first_step \
 --logging_steps 5 \
 --learning_rate 1e-2 \
 --evaluation_strategy steps \
 --eval_steps 10 \
 --to_layer 2 
```


### Train your custom model

Run the custom model via the path `models/custom-model-demo.py`.
You can define your custom model by modifying the demo script.

```python
python run_pos.py \
 --model_name_or_path models/custom-model-demo.py \
 --output_dir /tmp/pos-exp-1 \
 --task_name pos \
 --dataset_script ontonotes_v4.py \
 --max_seq_length 63 \
 --per_device_train_batch_size 16 \
 --per_device_eval_batch_size 8 \
 --num_train_epochs 3 \
 --do_train \
 --do_eval \
 --do_predict
  --learning_rate 1e-2 \
```

### Quicker training  

If you'd like to further develop the model or debugging it. 
The options `max_train_samples`, `max_vall_samples` and `max_test_samples` allow you to truncate the number of examples.
They recieve digits digit format.

```
python run_pos.py \
 --model_name_or_path models/custom-model-demo.py \
 --output_dir /tmp/pos-exp-1 \
 --task_name pos \
 --dataset_script ontonotes_v4.py \
 --max_seq_length 63 \
 --per_device_train_batch_size 24 \
 --per_device_eval_batch_size 8 \
 --num_train_epochs 3 \
 --do_train \
 --do_eval \
 --do_predict \
 --max_train_samples 10000 \
 --max_val_samples 1000 \
 --max_test_samples 1000 \
 --logging_steps 20 
 --learning_rate 1e-2 \
```


